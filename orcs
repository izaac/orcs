#!/bin/sh

# orcs
# This is a POSIX-compliant shell wrapper for the OpenRC status tool.
# It uses a modular design by calling the orcs.awk script.

# Determine the directory of the script to correctly source files.
SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Check that the style.sh file exists before sourcing it.
if [ ! -f "${SCRIPT_DIR}/style.sh" ]; then
  echo "Error: style.sh not found in the script directory." >&2
  exit 1
fi
. "${SCRIPT_DIR}/style.sh"

# Function to get and display services
get_and_display_services() {
  view_flag="$1"
  sort_by="$2"

  all_output=""
  if ! all_output=$(sudo rc-status --all 2>&1); then
    print_error "Error running 'rc-status --all':"
    echo "$all_output" >&2
    return 1
  fi

  unused_output=""
  if ! unused_output=$(sudo rc-status --unused 2>&1); then
    print_error "Error running 'rc-status --unused':"
    echo "$unused_output" >&2
    return 1
  fi

  sort_key=4
  if [ "$sort_by" = "name" ]; then
    sort_key=1
  fi

  formatted_output=""
  # Combine outputs and pipe to awk for parsing and formatting.
  # We pass all necessary variables to awk for a self-contained script.
  formatted_output=$(
    printf '%s\n' "$all_output" "$unused_output" | "${SCRIPT_DIR}/orcs.awk" -v GREEN="$GREEN" -v RED="$RED" -v YELLOW="$YELLOW" -v CYAN="$CYAN" -v MAGENTA="$MAGENTA" -v NC="$NC" -v view_flag="$view_flag" | sort -t ';' -k "$sort_key"
  )

  # Print the header and use column to format the output into a neat table.
  printf "%s;%s;%s;%s\n" "${GREEN}Service" "Status" "PID" "Runlevel${NC}" | column -s';' -t
  printf "%s\n" "${GREEN}-----------------------------------------------------------------------${NC}"
  echo "$formatted_output" | column -s';' -t
}

# Function to display the help message
show_help() {
  print_info "Usage: orcs [OPTIONS]"
  echo ""
  print_info "Options:"
  printf "  %s%s%s            Display only active services (default)\n" "$BOLD" "-a, --active" "$NC"
  printf "  %s%s%s          Display inactive (stopped or disabled) services\n" "$BOLD" "-i, --inactive" "$NC"
  printf "  %s%s%s               Display all services, active and inactive\n" "$BOLD" "-A, --all" "$NC"
  printf "  %s%s%s         Sort services alphabetically by name\n" "$BOLD" "-s, --sort-name" "$NC"
  printf "  %s%s%s     Sort services alphabetically by runlevel\n" "$BOLD" "-r, --sort-runlevel" "$NC"
  printf "  %s%s%s              Show this help message and exit\n" "$BOLD" "-h, --help" "$NC"
}

# Main script logic
main() {
  sort_by=""
  view_flag="active"

  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -a | --active) view_flag="active" ;;
    -i | --inactive) view_flag="inactive" ;;
    -A | --all) view_flag="all" ;;
    -s | --sort-name) sort_by="name" ;;
    -r | --sort-runlevel) sort_by="runlevel" ;;
    -h | --help)
      show_help
      return 0
      ;;
    *) print_warning "Unknown argument: $1. Ignoring." ;;
    esac
    shift
  done

  get_and_display_services "$view_flag" "$sort_by"
}

main "$@"
