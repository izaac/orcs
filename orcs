#!/bin/sh

# orcs
# A POSIX-compliant shell wrapper for viewing OpenRC services.
# It uses helper awk scripts for parsing and formatting.

# Determine the directory of the script to correctly source files.
SCRIPT_DIR=$(dirname "$0")

# Check that all required script files exist before sourcing.
for file in style.sh orcs-parse.awk orcs-format.awk; do
  if [ ! -f "${SCRIPT_DIR}/${file}" ]; then
    echo "Error: Dependency '${file}' not found in the script directory." >&2
    exit 1
  fi
done
. "${SCRIPT_DIR}/style.sh"

# Function to get and display services
get_and_display_services() {
  view_flag="$1"
  sort_by="$2"

  all_output=""
  if ! all_output=$(sudo rc-status --all 2>&1); then
    print_error "Error running 'rc-status --all':"
    echo "$all_output" >&2
    return 1
  fi

  unused_output=""
  if ! unused_output=$(sudo rc-status --unused 2>&1); then
    print_error "Error running 'rc-status --unused':"
    echo "$unused_output" >&2
    return 1
  fi

  # 1. Parse the raw output into simple, semicolon-separated lines.
  parsed_output=$(
    printf '%s\n' "$all_output" "$unused_output" | awk -f "${SCRIPT_DIR}/orcs-parse.awk"
  )

  # Run ps only once and store the process list for efficiency.
  proc_list=$(/bin/ps -o pid,comm,args ax)

  # 2. Process each line to add PIDs/colors, then sort the results.
  sort_key=4 # Default sort by runlevel
  [ "$sort_by" = "name" ] && sort_key=1

  sorted_data=$(
    printf "%s\n" "$parsed_output" | while IFS= read -r line; do
      # Use POSIX-compliant parameter expansion to split the line.
      service="${line%%;*}"
      temp="${line#*;}"
      status="${temp%%;*}"
      runlevel="${temp#*;}"

      # Filter services based on the view_flag.
      case "$view_flag" in
      "active") [ "$status" != "started" ] && continue ;;
      "inactive") [ "$status" = "started" ] && continue ;;
      esac

      # Skip PID lookup for non-started services or placeholder services.
      if [ "$status" != "started" ] || [ "$service" = "acpid" ] || [ "$service" = "local" ]; then
        pid="-"
      else
        # Search the stored $proc_list variable instead of running ps again.
        # First, try to match the exact command name (column 2).
        pid=$(printf "%s\n" "$proc_list" | awk -v s="$service" '$2 == s {print $1; exit}')

        # If that fails, try a flexible substring search on the full arguments.
        if [ -z "$pid" ]; then
          pid=$(printf "%s\n" "$proc_list" | awk -v s="$service" 'NR>1 && index($0, s) && !/awk/ && !/orcs/ {print $1; exit}')
        fi

        # If still no PID, default to "-".
        [ -z "$pid" ] && pid="-"
      fi

      # Add color and symbols to the status text.
      status_text="${YELLOW}‚ö†Ô∏è ${status}${NC}"
      if [ "$status" = "started" ]; then
        status_text="${GREEN}‚úÖ ${status}${NC}"
      elif [ "$status" = "stopped" ]; then
        status_text="${RED}‚ùå ${status}${NC}"
      elif [ "$status" = "disabled" ]; then
        status_text="${YELLOW}üö´ ${status}${NC}"
      fi

      # Print the fully formatted line to be piped to the sort command.
      printf "%s\n" "${CYAN}${service}${NC};${status_text};${MAGENTA}${pid}${NC};${BLUE}${runlevel}${NC}"
    done | sort -t ';' -k "$sort_key"
  )

  # 3. Format the final output into a neat table.
  header="${GREEN}Service;Status;PID;Runlevel${NC}"

  # Group the header and sorted data into a single stream for the formatter.
  {
    printf "%s\n" "$header"
    printf "%s\n" "$sorted_data"
  } | awk -f "${SCRIPT_DIR}/orcs-format.awk"
}

# Function to display the help message
show_help() {
  print_info "Usage: orcs [OPTIONS]"
  echo ""
  print_info "Options:"
  printf "  %s%s%s            Display only active services (default)\n" "$BOLD" "-a, --active" "$NC"
  printf "  %s%s%s          Display inactive (stopped or disabled) services\n" "$BOLD" "-i, --inactive" "$NC"
  printf "  %s%s%s               Display all services, active and inactive\n" "$BOLD" "-A, --all" "$NC"
  printf "  %s%s%s         Sort services alphabetically by name\n" "$BOLD" "-s, --sort-name" "$NC"
  printf "  %s%s%s     Sort services alphabetically by runlevel\n" "$BOLD" "-r, --sort-runlevel" "$NC"
  printf "  %s%s%s              Show this help message and exit\n" "$BOLD" "-h, --help" "$NC"
}

# Main script logic
main() {
  sort_by=""
  view_flag="active"

  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -a | --active) view_flag="active" ;;
    -i | --inactive) view_flag="inactive" ;;
    -A | --all) view_flag="all" ;;
    -s | --sort-name) sort_by="name" ;;
    -r | --sort-runlevel) sort_by="runlevel" ;;
    -h | --help)
      show_help
      return 0
      ;;
    *) print_warning "Unknown argument: $1. Ignoring." ;;
    esac
    shift
  done

  get_and_display_services "$view_flag" "$sort_by"
}

main "$@"
