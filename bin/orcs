#!/bin/sh

# orcs
# A POSIX-compliant shell wrapper for viewing and managing OpenRC services.
# It uses helper awk scripts for parsing and formatting.

# Determine the directory of the script to correctly source files.
# The main 'orcs' script will be in 'bin', so the library is one level up.
SCRIPT_DIR=$(dirname "$0")
LIB_DIR="${SCRIPT_DIR}/../lib"

# Check that all required script files exist before sourcing.
for file in style.sh orcs-parse.awk orcs-format.awk; do
  if [ ! -f "${LIB_DIR}/${file}" ];
  then
    echo "Error: Dependency '${file}' not found in '${LIB_DIR}'." >&2
    exit 1
  fi
done
. "${LIB_DIR}/style.sh"

# --- Core Functions ---

# Generates a list of all services with their current status and runlevel.
generate_service_list() {
  all_output=""
  if ! all_output=$(sudo rc-status --all 2>&1); then
    print_error "Error running 'rc-status --all':"
    echo "$all_output" >&2
    exit 1
  fi

  unused_output=""
  if ! unused_output=$(sudo rc-status --unused 2>&1); then
    print_error "Error running 'rc-status --unused':"
    echo "$unused_output" >&2
    return 1
  fi

  # Parse the raw output into simple, semicolon-separated lines.
  printf '%s\n' "$all_output" "$unused_output" | awk -f "${LIB_DIR}/orcs-parse.awk"
}

# Displays a formatted table of services.
display_service_table() {
  view_flag="$1"
  sort_by="$2"

  parsed_output=$(generate_service_list)
  proc_list=$(/bin/ps -o pid,comm,args ax)

  # Process each line to add PIDs and colors.
  data_to_filter=$(
    printf "%s\n" "$parsed_output" | while IFS= read -r line; do
        service="${line%%;*}"
        temp="${line#*;}"
        status="${temp%%;*}"
        runlevel="${temp#*;}"

        if [ "$status" != "started" ] || [ "$service" = "acpid" ] || [ "$service" = "local" ]; then
            pid="-"
        else
            pid=$(printf "%s\n" "$proc_list" | awk -v s="$service" '$2 == s {print $1; exit}')
            if [ -z "$pid" ]; then
                pid=$(printf "%s\n" "$proc_list" | awk -v s="$service" 'NR>1 && index($0, s) && !/awk/ && !/orcs/ {print $1; exit}')
            fi
            [ -z "$pid" ] && pid="-"
        fi
        
        status_text="${YELLOW}‚ö†Ô∏è ${status}${NC}"
        if [ "$status" = "started" ]; then status_text="${GREEN}‚úÖ ${status}${NC}"; fi
        if [ "$status" = "stopped" ]; then status_text="${RED}‚ùå ${status}${NC}"; fi
        if [ "$status" = "disabled" ]; then status_text="${YELLOW}üö´ ${status}${NC}"; fi

        printf "%s\n" "${CYAN}${service}${NC};${status_text};${MAGENTA}${pid}${NC};${BLUE}${runlevel}${NC}"
    done
  )

  # Apply the view filter.
  case "$view_flag" in
    "active")
      data_to_sort=$(printf "%s\n" "$data_to_filter" | grep "‚úÖ")
      ;;
    "inactive")
      data_to_sort=$(printf "%s\n" "$data_to_filter" | grep -E "‚ùå|üö´")
      ;;
    *) # Default to "all"
      data_to_sort="$data_to_filter"
      ;;
  esac

  # Sort the filtered data based on the chosen option.
  case "$sort_by" in
    "name")
      # Sort by service name (column 1).
      sorted_data=$(printf "%s\n" "$data_to_sort" | sort -t ';' -k 1,1)
      ;;
    *) # Default to runlevel
      # Sort by runlevel (column 4), then by service name (column 1).
      sorted_data=$(printf "%s\n" "$data_to_sort" | sort -t ';' -k 4,4 -k 1,1)
      ;;
  esac

  # Format the final output into a neat table.
  header="${GREEN}Service;Status;PID;Runlevel${NC}"
  {
    printf "%s\n" "$header"
    printf "%s\n" "$sorted_data"
  } | awk -f "${LIB_DIR}/orcs-format.awk"
}

# Manages a single service (start, stop, restart).
manage_service() {
    action="$1"
    service_name="$2"

    if [ -z "$service_name" ]; then
        print_error "Error: Missing service name. Usage: orcs $action <SERVICE_NAME>"
        exit 1
    fi

    printf "Service: %s\n" "${CYAN}${service_name}${NC}"
    printf "Action:  %s\n" "${BOLD}${action}${NC}"
    
    printf "Status before: "
    sudo rc-service "$service_name" status
    
    printf "\n"
    sudo rc-service "$service_name" "$action"
    
    printf "\nStatus after:  "
    sudo rc-service "$service_name" status
}

# --- Main Execution Logic ---

show_help() {
  print_info "Usage: orcs [COMMAND | OPTIONS]"
  echo ""
  print_info "Commands:"
  printf "  %s <SERVICE>%s      Stop a service by its name\n" "stop"
  printf "  %s <SERVICE>%s     Start a service by its name\n" "start"
  printf "  %s <SERVICE>%s   Restart a service by its name\n" "restart"
  echo ""
  print_info "Options:"
  printf "  %s%s%s            Display only active services (default)\n" "$BOLD" "-a, --active" "$NC"
  printf "  %s%s%s          Display inactive (stopped or disabled) services\n" "$BOLD" "-i, --inactive" "$NC"
  printf "  %s%s%s               Display all services, active and inactive\n" "$BOLD" "-A, --all" "$NC"
  printf "  %s%s%s         Sort services alphabetically by name\n" "$BOLD" "-s, --sort-name" "$NC"
  printf "  %s%s%s     Sort services by runlevel (default)\n" "$BOLD" "-r, --sort-runlevel" "$NC"
  printf "  %s%s%s              Show this help message and exit\n" "$BOLD" "-h, --help" "$NC"
}

main() {
  case "$1" in
    start|stop|restart)
      manage_service "$1" "$2"
      exit 0
      ;;
  esac

  sort_by=""
  view_flag="active"
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -a | --active) view_flag="active" ;;
    -i | --inactive) view_flag="inactive" ;;
    -A | --all) view_flag="all" ;;
    -s | --sort-name) sort_by="name" ;;
    -r | --sort-runlevel) sort_by="runlevel" ;;
    -h | --help)
      show_help
      return 0
      ;;
    *)
      print_error "Unknown command or option: $1"
      show_help
      exit 1
      ;;
    esac
    shift
  done

  display_service_table "$view_flag" "$sort_by"
}

main "$@"
