#!/bin/sh

# orcs
# A POSIX-compliant shell wrapper for viewing and managing OpenRC services.
# It uses helper awk scripts for parsing and formatting.

# Find the real directory of the script, resolving symlinks.
REAL_PATH="$0"
while [ -L "$REAL_PATH" ]; do
  DIR=$(dirname "$REAL_PATH")
  REAL_PATH=$(readlink "$REAL_PATH")
  case "$REAL_PATH" in
  /*) ;;
  *) REAL_PATH="$DIR/$REAL_PATH" ;;
  esac
done
SCRIPT_DIR=$(dirname "$REAL_PATH")
LIB_DIR="${SCRIPT_DIR}/../lib"

# Check that all required script files exist before sourcing.
for file in style.sh orcs-parse.awk orcs-decorate.awk orcs-format.awk; do
  if [ ! -f "${LIB_DIR}/${file}" ]; then
    echo "Error: Dependency '${file}' not found in '${LIB_DIR}'." >&2
    exit 1
  fi
done
. "${LIB_DIR}/style.sh"

# --- Core Functions ---

# Generates a list of all services with their current status and runlevel.
generate_service_list() {
  all_output=""
  if ! all_output=$(sudo rc-status --all 2>&1); then
    print_error "Error running 'rc-status --all':"
    echo "$all_output" >&2
    exit 1
  fi

  unused_output=""
  if ! unused_output=$(sudo rc-status --unused 2>&1); then
    print_error "Error running 'rc-status --unused':"
    echo "$unused_output" >&2
    return 1
  fi

  # Parse the raw output into simple, semicolon-separated lines.
  printf '%s\n' "$all_output" "$unused_output" | awk -f "${LIB_DIR}/orcs-parse.awk"
}

# Displays a formatted table of services.
display_service_table() {
  view_flag="$1"
  sort_by="$2"

  parsed_output=$(generate_service_list)
  proc_list=$(/bin/ps -o pid,args ax)

  # Process the data with the new, efficient awk script.
  data_to_filter=$(
    {
      printf "%s\n" "$proc_list"
      printf "%s\n" "---PROCESS_LIST_END---"
      printf "%s\n" "$parsed_output"
    } | awk \
      -v GREEN="$GREEN" -v RED="$RED" -v YELLOW="$YELLOW" \
      -v CYAN="$CYAN" -v MAGENTA="$MAGENTA" -v NC="$NC" \
      -f "${LIB_DIR}/orcs-decorate.awk"
  )

  # Apply the view filter.
  case "$view_flag" in
  "active")
    data_to_sort=$(printf "%s\n" "$data_to_filter" | grep "‚úÖ")
    ;;
  "inactive")
    data_to_sort=$(printf "%s\n" "$data_to_filter" | grep -E "‚ùå|üö´")
    ;;
  *) # Default to "all"
    data_to_sort="$data_to_filter"
    ;;
  esac

  # Sort the filtered data based on the chosen option.
  case "$sort_by" in
  "name")
    # Sort by service name (column 1).
    sorted_data=$(printf "%s\n" "$data_to_sort" | sort -t ';' -k 1,1)
    ;;
  *) # Default to runlevel
    # Sort by runlevel (column 4), then by service name (column 1).
    sorted_data=$(printf "%s\n" "$data_to_sort" | sort -t ';' -k 4,4 -k 1,1)
    ;;
  esac

  # Format the final output into a neat table.
  header="${GREEN}Service;Status;PID;Runlevel${NC}"
  {
    printf "%s\n" "$header"
    printf "%s\n" "$sorted_data"
  } | awk -f "${LIB_DIR}/orcs-format.awk"
}

# Manages a single service (start, stop, restart).
manage_service() {
  action="$1"
  service_name="$2"

  if [ -z "$service_name" ]; then
    print_error "Error: Missing service name. Usage: orcs $action <SERVICE_NAME>"
    exit 1
  fi

  printf "Service: %s\n" "${CYAN}${service_name}${NC}"
  printf "Action:  %s\n" "${BOLD}${action}${NC}"

  printf "Status before: "
  sudo rc-service "$service_name" status

  printf "\n"
  sudo rc-service "$service_name" "$action"

  printf "\nStatus after:  "
  sudo rc-service "$service_name" status
}

# --- Main Execution Logic ---

show_help() {
  print_info "Usage: orcs [COMMAND | OPTIONS]"
  echo ""
  print_info "Commands:"
  printf "  %s%s%s <SERVICE>      Stop a service by its name\n" "$BOLD" "stop" "$NC"
  printf "  %s%s%s <SERVICE>     Start a service by its name\n" "$BOLD" "start" "$NC"
  printf "  %s%s%s <SERVICE>   Restart a service by its name\n" "$BOLD" "restart" "$NC"
  echo ""
  print_info "Options:"
  printf "  %s%s%s            Display only active services (default)\n" "$BOLD" "-a, --active" "$NC"
  printf "  %s%s%s          Display inactive (stopped or disabled) services\n" "$BOLD" "-i, --inactive" "$NC"
  printf "  %s%s%s               Display all services, active and inactive\n" "$BOLD" "-A, --all" "$NC"
  printf "  %s%s%s         Sort services alphabetically by name\n" "$BOLD" "-s, --sort-name" "$NC"
  printf "  %s%s%s     Sort services by runlevel (default)\n" "$BOLD" "-r, --sort-runlevel" "$NC"
  printf "  %s%s%s              Show this help message and exit\n" "$BOLD" "-h, --help" "$NC"
}

main() {
  case "$1" in
  start | stop | restart)
    manage_service "$1" "$2"
    exit 0
    ;;
  esac

  sort_by=""
  view_flag="active"
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -a | --active) view_flag="active" ;;
    -i | --inactive) view_flag="inactive" ;;
    -A | --all) view_flag="all" ;;
    -s | --sort-name) sort_by="name" ;;
    -r | --sort-runlevel) sort_by="runlevel" ;;
    -h | --help)
      show_help
      return 0
      ;;
    *)
      print_error "Unknown command or option: $1"
      show_help
      exit 1
      ;;
    esac
    shift
  done

  display_service_table "$view_flag" "$sort_by"
}

main "$@"
